# -*- coding: utf-8 -*-
"""IEEE_Crop.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16rBALZJhUjiuwTUKlNzKhCokX_cjmN4w
"""

import numpy as np
import pandas as pd
import time
import json
import requests
import gc
from datetime import datetime, timedelta
from dateutil import tz
from tqdm.notebook import tqdm

from matplotlib import pyplot as plt
import seaborn as sns

from http.server import HTTPServer, BaseHTTPRequestHandler 

import warnings
warnings.filterwarnings("ignore")

def main():
  PORT = 8000
  server = HTTPServer(('',PORT), helloHandler)
  print(f"Serever Running on port {PORT}")
  serever.serve_forever()

# here i receive the latitue and longitude for the user
#lati = 
#longi = 
#INPUT_STATE  =

#API_KEY = 'cd1b1ab918ac58e92920f2eb06f18399'


def fetch_current():

  df_forecast = pd.DataFrame() 


  to_zone = tz.gettz('Asia/Kolkata')
  utc = datetime.now()
  central = utc.astimezone(to_zone)

  # DATES TO FETCH
  N=1
  current_date = central.date() + timedelta(days=1)
  
  for i in range(0,2):                          # ****** MAIN FOR-LOOP *******
      current_date = current_date - timedelta(days=N)
      past_day = current_date - timedelta(days=N)
      print(current_date,past_day)


      #                 ************** WEATHER_BIT API CONNECTION ***************
    

      API_KEY = 'a2dedde8a62e4379ad51f283bc75ee5c'
    
      if i ==0:
        url = f"https://api.weatherbit.io/v2.0/forecast/daily?lat=38.12&lon=-78.543&tz=local&key={API_KEY}"
        data = 'data'
      else:
        url = f"https://api.weatherbit.io/v2.0/alerts?lat=38.12&lon=-78.543&tz=local&key={API_KEY}"
        data = 'alerts'
      
      response = requests.get(url)

      print(response.status_code)
      weather = json.loads(response.text) 
      if i ==1:
        alerts_json = weather
      print (json.dumps(weather,indent=1)) 
      
    
      
                      #*************** CONVERSION TO DATAFRAME ****************
      if i ==0:
    

        df_current = pd.DataFrame.from_dict(weather[data][0],orient='index').transpose()
        for forecast in weather[data][1:]:
            df_current = pd.concat([df_current, pd.DataFrame.from_dict(forecast,orient='index').transpose()])
 
  
      
        time_ = np.array(df_current['datetime'])
        for row in range(len(time_)):
            time_[row] = datetime.strptime(time_[row], '%Y-%m-%d')
        df_current = df_current.set_index(time_)
        df_current = df_current.sort_index()
        df_forecast = df_current.copy()
      
  
  print("Fetch completed...!!!  :)")
  
  
  del df_current
  gc.collect()

  return df_forecast, alerts_json

df_forecast,alerts_json = fetch_current()



df_result = pd.DataFrame()
df = pd.read_csv("/content/apy.csv")
df['Laterite'] ='NIL'
df['Red loam'] ='NIL'
df['Alluvilial'] = 'NIL'
df['Clay'] = 'NIL'
df['Loamy'] = 'NIL'
df['Sandy loam'] = 'NIL'
df['sandy'] = 'NIL'
df['red sandy'] = 'NIL'
df['well_drained'] = 'NIL'
df['black_cotton'] = 'NIL'
df.head()

df_crop_soil = pd.read_csv("/content/crop_soil.csv",encoding = 'unicode_escape')
df_crop_soil.head()

cr = df.Crop.unique()
cr_cs = df_crop_soil.crops.unique()
for i in cr :
  if i not in cr_cs:
    print(i)

crop_number = {}
for i in range(df_crop_soil.shape[0]):
  crop_number[df_crop_soil.crops[i]] = i
print(crop_number)

disallow = ['Ricebean (nagadal)','Pome Granet','Other Kharif pulses','other oilseeds','other misc. pulses','Other  Rabi pulses','other fibres','Other Fresh Fruits','Other Vegetables','Other Cereals & Millets','Cond-spcs other','Total foodgrain','Jobster','Ber','Other Dry Fruit']
for i in tqdm(range(df.shape[0])):
  if df.Crop[i] not in disallow:
    num = crop_number[df.Crop[i]]
    df['Laterite'][i]= df_crop_soil.Laterite[num]

    
    df['Red loam'][i]= df_crop_soil['Red loam'][num]

    
    df['Alluvilial'][i]= df_crop_soil.Alluvilial[num]

    df['Clay'][i]= df_crop_soil.Clay[num]

    df['Loamy'][i]= df_crop_soil.Loamy[num]

    
    df['Sandy loam'][i]= df_crop_soil['Sandy loam'][num]

    df['sandy'][i]= df_crop_soil.sandy[num]
    
    df['red sandy'][i]= df_crop_soil['red sandy'][num]

    df['well_drained'][i]=df_crop_soil.well_drained[num]

    df['black_cotton'][i]= df_crop_soil.black_cotton[num]

df.to_csv("new_df.csv")

crops = df.Crop.unique()
crops_production = {}
for i in crops:
  crops_production[i] = df.loc[df.Crop==i].Production.sum()
print(crops_production)

states = df.State_Name.unique()
state_wise_crops = {}
for i in tqdm(states):
  state_wise_crops[i] = []
  df_state_uniq_crops = df.loc[df.State_Name==i].Crop.unique()
  for j in df_state_uniq_crops:  
    temp  = {}
    temp[j] = df.loc[(df.State_Name == i) & (df.Crop == j)].Production.sum()
    state_wise_crops[i].append(temp)

state_wise_crops

df.loc[(df.Crop=='Rice') & (df.Crop_Year==2014)].State_Name.unique()

df_we_need = pd.DataFrame(columns=['crops','soil_type','temperature_req','water_req','time_required','seeds_per_hectare','MSP'])
df_we_need['crops'] = crops  
df_we_need.head()

import pandas as pd
import numpy as np

from catboost import CatBoostClassifier

#Separating label data for training
X = train.drop('target',axis=1)
Y = train['target']

threshold = 
X_train  = X[]
X_test = X[]
Y_train = Y[]
Y_test  = Y[]

model = CatBoostClassifier(iterations=1500, learning_rate=0.01, l2_leaf_reg=3.5, depth=8, rsm=0.98, loss_function= 'Logloss', eval_metric='AUC',use_best_model=True,random_seed=42)

df_we_need.to_csv("Crop_data.csv")